#!/usr/bin/env python3
"""
Bootstrap GitHub repo metadata for the Self-Evolving Web Application.

What it does:
- Creates/updates a required label taxonomy (idempotent).
- Optionally creates the 'production' environment (no required reviewers).

Auth:
- Set GITHUB_TOKEN env var (fine-grained PAT recommended for setup).
- Token must have permission to manage Issues/Labels in the target repo.
"""

from __future__ import annotations

import argparse
import os
import sys
import textwrap
from dataclasses import dataclass
from typing import Iterable, Optional

import requests


@dataclass(frozen=True)
class LabelSpec:
    name: str
    color: str  # 6-hex chars without '#'
    description: str


def die(msg: str, code: int = 1) -> None:
    print(f"ERROR: {msg}", file=sys.stderr)
    sys.exit(code)


def gh_request(session: requests.Session, method: str, url: str, **kwargs) -> requests.Response:
    resp = session.request(method, url, timeout=30, **kwargs)
    if resp.status_code >= 400:
        try:
            detail = resp.json()
        except Exception:
            detail = resp.text
        raise RuntimeError(f"GitHub API {method} {url} failed: {resp.status_code} {detail}")
    return resp


def get_all_labels(session: requests.Session, api_base: str) -> dict[str, dict]:
    labels: dict[str, dict] = {}
    page = 1
    while True:
        url = f"{api_base}/labels"
        resp = gh_request(session, "GET", url, params={"per_page": 100, "page": page})
        batch = resp.json()
        if not batch:
            break
        for item in batch:
            labels[item["name"]] = item
        page += 1
    return labels


def upsert_label(session: requests.Session, api_base: str, spec: LabelSpec, existing: Optional[dict]) -> None:
    if existing is None:
        # Create
        gh_request(
            session,
            "POST",
            f"{api_base}/labels",
            json={"name": spec.name, "color": spec.color, "description": spec.description},
        )
        print(f"Created label: {spec.name}")
        return

    # Update if needed
    need_update = (
        existing.get("color", "").lower() != spec.color.lower()
        or (existing.get("description") or "") != spec.description
    )
    if not need_update:
        print(f"OK label: {spec.name}")
        return

    # GitHub updates labels via PATCH /labels/{name}
    gh_request(
        session,
        "PATCH",
        f"{api_base}/labels/{requests.utils.quote(spec.name, safe='')}",
        json={"new_name": spec.name, "color": spec.color, "description": spec.description},
    )
    print(f"Updated label: {spec.name}")


def ensure_environment(session: requests.Session, api_base: str, env_name: str) -> None:
    """
    Create or update a deployment environment.
    For MVP we only ensure it exists; we DO NOT configure reviewers (none required).
    """
    # REST: PUT /repos/{owner}/{repo}/environments/{environment_name}
    gh_request(
        session,
        "PUT",
        f"{api_base}/environments/{requests.utils.quote(env_name, safe='')}",
        json={
            # We intentionally do not set reviewers.
            # 'deployment_branch_policy' omitted to keep default behavior.
        },
    )
    print(f"Ensured environment exists: {env_name} (no required reviewers configured by this script)")


def build_label_specs(include_severity: bool = True, include_gate: bool = True) -> list[LabelSpec]:
    # Color choices are arbitrary but consistent; adjust freely.
    specs: list[LabelSpec] = []

    # Request type
    specs += [
        LabelSpec("request:bug", "d73a4a", "User-reported bug"),
        LabelSpec("request:feature", "0e8a16", "User-requested feature"),
        LabelSpec("request:investigate", "fbca04", "Investigation request (often from monitoring)"),
    ]

    # Source
    specs += [
        LabelSpec("source:user", "5319e7", "Submitted by a human user via UI"),
        LabelSpec("source:monitor", "1d76db", "Generated by monitoring component"),
    ]

    # Priority
    specs += [
        LabelSpec("priority:p0", "b60205", "Urgent / highest priority"),
        LabelSpec("priority:p1", "d93f0b", "High priority"),
        LabelSpec("priority:p2", "fbca04", "Normal priority"),
    ]

    # Stages (state machine)
    specs += [
        LabelSpec("stage:triage", "c5def5", "Queued for triage workflow"),
        LabelSpec("stage:plan", "c5def5", "Queued for planning workflow"),
        LabelSpec("stage:prioritize", "c5def5", "Queued for prioritization workflow"),
        LabelSpec("stage:awaiting-implementation-approval", "c5def5", "Waiting for human approval to implement"),
        LabelSpec("stage:implement", "c5def5", "Queued for implementation workflow"),
        LabelSpec("stage:pr-opened", "c5def5", "PR opened; awaiting merge"),
        LabelSpec("stage:awaiting-deploy-approval", "c5def5", "Reserved (not used in MVP if merge triggers deploy)"),
        LabelSpec("stage:done", "0e8a16", "Completed"),
        LabelSpec("stage:blocked", "d73a4a", "Blocked; requires human intervention"),
    ]

    # Agent
    specs += [
        LabelSpec("agent:claude", "000000", "Created by Claude workflow automation"),
    ]

    if include_severity:
        specs += [
            LabelSpec("severity:critical", "b60205", "Critical severity"),
            LabelSpec("severity:high", "d93f0b", "High severity"),
            LabelSpec("severity:normal", "fbca04", "Normal severity"),
        ]

    if include_gate:
        specs += [
            LabelSpec("gate:auto", "0e8a16", "Policy gate: allowed"),
            LabelSpec("gate:review-required", "fbca04", "Policy gate: requires human review"),
            LabelSpec("gate:blocked", "d73a4a", "Policy gate: blocked"),
        ]

    return specs


def main() -> None:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Bootstrap labels (and optionally environments) for a GitHub repo.",
        epilog=textwrap.dedent(
            """
            Examples:
              export GITHUB_TOKEN=...
              python scripts/bootstrap_github.py --repo jungmats/self-evolving-app --ensure-env production
              python scripts/bootstrap_github.py --repo jungmats/self-evolving-app --dry-run
            """
        ),
    )
    parser.add_argument("--repo", required=True, help="owner/repo (e.g., jungmats/self-evolving-app)")
    parser.add_argument("--dry-run", action="store_true", help="Show what would change, but do not write.")
    parser.add_argument("--ensure-env", default=None, help="Environment name to ensure exists (e.g., production).")
    parser.add_argument("--no-severity", action="store_true", help="Do not manage severity:* labels.")
    parser.add_argument("--no-gate", action="store_true", help="Do not manage gate:* labels.")
    args = parser.parse_args()

    token = os.getenv("GITHUB_TOKEN")
    if not token:
        die("GITHUB_TOKEN env var is required (fine-grained PAT recommended).")

    owner_repo = args.repo.strip()
    if "/" not in owner_repo:
        die("--repo must be in owner/repo format.")

    api_base = f"https://api.github.com/repos/{owner_repo}"

    session = requests.Session()
    session.headers.update(
        {
            "Authorization": f"Bearer {token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "User-Agent": "self-evolving-app-bootstrap",
        }
    )

    specs = build_label_specs(include_severity=not args.no_severity, include_gate=not args.no_gate)

    existing = get_all_labels(session, api_base)

    # Compute changes
    to_create = [s for s in specs if s.name not in existing]
    to_maybe_update = [s for s in specs if s.name in existing]

    print(f"Repo: {owner_repo}")
    print(f"Existing labels: {len(existing)}")
    print(f"Managed labels: {len(specs)}")
    print(f"Would create: {len(to_create)}")
    print(f"Would check/update: {len(to_maybe_update)}")

    if args.dry_run:
        if to_create:
            print("\nLabels to create:")
            for s in to_create:
                print(f"  - {s.name}")
        print("\nDry-run mode: no changes applied.")
        return

    # Apply changes
    for spec in specs:
        upsert_label(session, api_base, spec, existing.get(spec.name))

    if args.ensure_env:
        ensure_environment(session, api_base, args.ensure_env)

    print("\nDone.")


if __name__ == "__main__":
    main()
